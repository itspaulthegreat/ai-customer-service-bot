import wixStores from 'wix-stores';
import wixUsers from "wix-users";
import { myGetCurrentCartFunction } from "backend/my-backend-file.web";
import wixEcomFrontend from "wix-ecom-frontend";
import wixWindowFrontend from "wix-window-frontend";
import wixWindow from 'wix-window';
import wixLocation from 'wix-location';
import { publishCartUpdate } from 'backend/realtime.jsw';
import wixData from 'wix-data';
import { submitReview, checkReviewEligibility, getApprovedReviews, getApprovedReviewsWithImages, getRejectedReview } from 'backend/reviews.web';
import {toggleWishlist, getWishlistProductIds} from 'backend/utilsApis/wishlistAPIs'
import { MessageHandler, getUserId } from 'public/utils';
import { CONSTANTS } from 'public/constants';
import { URLS } from 'public/urls';
import { local } from 'wix-storage';
import { checkPincodeTAT } from 'backend/Delhivery-api/apiFetchCalls.jsw'
import { fetchSimilarProducts, fetchTopChoices} from 'backend/repeaterAPIendpoints/repeaterUtils.jsw';
import { getCachedData } from 'backend/cachingData/cache.jsw';
import {
    addToLocalWishlist,
    removeFromLocalWishlist,
    getLocalWishlist,
    getLocalWishlistCount,
    isProductInLocalWishlist
} from 'public/APIs/wishlistUtils';

let images = [];
let currentIndex = 0;
let cachedCart = null;
let selectedSize = null;
let userId = null;
let currentFilter = 'newest';
let matchingOrderId = null;
let isQuickDetailsExpanded = false;
let currentImageIndex = 0; // Track current image in productImageRepeater
let repeaterData = []; // Store repeater data globally for access
let topChoicesData = [];
// Add debouncing and initialization flag
let isTopChoicesInitialized = false;
let debounceTimer = null;
let topChoicesStartIndex = 0;
let wishlistProductIds = new Set();
const DEBOUNCE_DELAY = 300;
const CACHE_TIMEOUT = CONSTANTS.CACHE_TIMEOUT;
const CACHE_KEYS = {
    TOP_CHOICES: CONSTANTS.CACHE_KEYS.TOP_CHOICES,
    SIMILAR_PRODUCTS: CONSTANTS.CACHE_KEYS.SIMILAR_PRODUCTS
};
let currentStartIndex = 0; // Track the starting index for repeater scrolling
const ITEMS_PER_PAGE = 5; // Number of items to show per scroll
let selectedQuantity = 1; // Default quantity
let FORMFACTOR = wixWindowFrontend.formFactor
let RATING_INPUT_ID = FORMFACTOR === "Desktop" ? '#ratingsInputDesktop' : FORMFACTOR === "Tablet" ? '#ratingsInputTablet' : '#ratingsInputMobile';
let GOTOCART_BTN = FORMFACTOR === "Desktop" ? '#goToCart' : "#goToCartTabMob"
let ADDTOCART_BTN = FORMFACTOR === "Desktop" ? '#addToCart' : "#addToCartTabMob"
let isSimilarProductsInitialized = false;
let similarDebounceTimer = null;
let similarProductsData = []; // Store all similar products globally
let similarStartIndex = 0; // Track the starting index for similar products repeater scrolling
let MAXQUANTITY = CONSTANTS.CART.MAX_QUANTITY

function createOptimizedDebounce(func, delay) {
    let timeoutId;
    let isExecuting = false;

    return async function (...args) {
        if (isExecuting) return;

        clearTimeout(timeoutId);
        isExecuting = true;

        try {
            await func.apply(this, args);
        } finally {
            timeoutId = setTimeout(() => {
                isExecuting = false;
            }, delay);
        }
    };
}


$w.onReady(async function () {
    let dataset = $w("#dynamicDataset");
    try {
        const user = wixUsers.currentUser;
        userId = user.loggedIn ? user.id : null;

        // Initialize wishlist and update count
        await initializeWishlistData(userId);
        await updateWishlistCount(userId);

        // Fetch data in parallel
        await Promise.all([
            dataset.onReady(async () => {
                let currentItem = dataset.getCurrentItem();
                // [Keep existing dataset.onReady logic for non-repeater parts]
                await fetchRepeaterData(currentItem._id);
                // Load repeaters after a short delay
                setTimeout(() => {
                    initializeRepeaters();
                }, 5);
            })
        ]);
    } catch (error) {
        console.error("Error in onReady:", error);
    }
    // Initialize quantity button and text
    if ($w("#quantityButton").type) {
        $w("#quantityButton").label = `Quantity : 0${selectedQuantity}`; // Initialize quantity display
        $w("#quantityButton").disable(); // Disable until size is selected
        $w("#quantityButton").onClick(async () => {
            const currentItem = $w("#dynamicDataset").getCurrentItem();
            if (!selectedSize) {
                MessageHandler.showMessage({ message: "Please select a size", type: "error" });
                return;
            }
            // Query allProductsVariants for stock
            try {
                const result = await wixData.query("allProductsVariants")
                    .eq("productId", currentItem._id)
                    .eq("choices.Size", selectedSize)
                    .find();
                let maxQuantity = MAXQUANTITY; // Default cap
                if (result.items.length > 0) {
                    const variant = result.items[0];
                    maxQuantity = Math.min(variant.stock.quantity || 1, MAXQUANTITY);
                    console.log("[Product Page Log] Fetched maxQuantity:", maxQuantity, "for size", selectedSize);
                } else {
                    console.warn("[Product Page Log] No variant found for product", currentItem._id, "size", selectedSize);
                    maxQuantity = 1;
                }
                // Open quantity lightbox
                const lightboxResult = await wixWindow.openLightbox("quantityLightbox", {
                    currentQuantity: selectedQuantity,
                    maxQuantity: maxQuantity
                });
                if (lightboxResult && lightboxResult.quantity) {
                    selectedQuantity = lightboxResult.quantity;
                    $w("#quantityButton").label = `Quantity : 0${selectedQuantity}`;
                    console.log("[Product Page Log] Quantity updated to:", selectedQuantity);
                    updateButtonState(currentItem);
                }
            } catch (error) {
                console.error("[Product Page Log] Error querying allProductsVariants for lightbox:", error);
                MessageHandler.showMessage({ message: "Failed to load quantity options.", type: "error" });
            }
        });
    }
    $w("#reviewForm").collapse();
    $w("#approvedReviewForm").collapse();
    $w("#reviewText").maxLength = CONSTANTS.REVIEWS.MAX_REVIEW_LENGTH;
    $w("#reviewImagePlaceholder").collapse();

    // Initialize review image HTML component
    $w("#reviewImageHtml").onMessage((event) => {
        if (event.data.type === "uploadReady") {
            // Send initial state to HTML component
            $w("#reviewImageHtml").postMessage({
                type: "initUpload",
                hasImage: false,
                label: "Add a Photo Review"
            });
        } else if (event.data.type === "imageSelected") {
            // Show placeholder with the resized image
            $w("#reviewImagePlaceholder").src = event.data.dataUrl;
            $w("#reviewImagePlaceholder").expand();
            // Update button label to "Change photo review"
            $w("#reviewImageHtml").postMessage({
                type: "initUpload",
                hasImage: true,
                label: "Change photo review"
            });
            // Show submit button only if rating and text are also present
            if ($w(RATING_INPUT_ID).value && $w("#reviewText").value) {
                $w("#submitReviewButton").show();
            }
        } else if (event.data.type === "uploadError") {
            console.error("Image upload error:", event.data.error);
            MessageHandler.showMessage({ message: event.data.error, type: "error", timeout: 3000 });
        }
    });

    // Initialize review filter dropdown
    $w("#reviewFilterDropdown").options = [
        { label: "Highest Rating", value: "highestRating" },
        { label: "Lowest Rating", value: "lowestRating" },
        { label: "Newest Review", value: "newest" },
        { label: "Oldest Review", value: "oldest" }
    ];
    $w("#reviewFilterDropdown").value = currentFilter;

    // Pre-fetch cart
    cachedCart = await fetchAndCacheCart();

    // Get user ID
    userId = await getUserId();
    let user = wixUsers.currentUser;
    let userID = user.loggedIn ? user.id : null;
    await updateWishlistCount(userID);

    // Initialize topChoicesRepeater


    dataset.onReady(async () => {
        let currentItem = dataset.getCurrentItem();
        let product = currentItem;
        console.log(product)
        await initializeReviews(currentItem);
        await displayReviewImages(currentItem._id);

        let Namearray = currentItem.name.split("|");
        $w("#dressName").text = Namearray[0].trim();
        $w("#brandName").text = Namearray[1]?.trim() || "";

        repeaterData = currentItem.mediaItems.map((item, index) => {
            let src = item.src;
            if (src.startsWith("wix:image://")) {
                const match = src.match(/wix:image:\/\/v1\/(.+?)(?:\/[^#]+)?(?:#.*)?$/);
                if (match && match[1]) {
                    src = `https://static.wixstatic.com/media/${match[1]}`;
                } else {
                    src = "";
                }
            }
            return {
                _id: (index + 1).toString(),
                src: src
            };
        });

        const validRepeaterData = repeaterData.filter(item => item.src && item.src.startsWith("https://static.wixstatic.com"));
        if (validRepeaterData.length !== repeaterData.length) {
            console.warn("Some images were filtered out due to invalid URLs");
        }

        $w("#productImageRepeater").onItemReady(($item, itemData, index) => {
            $item("#productImage").src = itemData.src;
        });
        if (FORMFACTOR === "Mobile" || FORMFACTOR === "Tablet") {
            $w("#productImageRepeater").hide();
            $w("#htmlSlideshow").show();

            const validRepeaterData = repeaterData.filter(item => item.src && item.src.startsWith("https://static.wixstatic.com"));
            if (validRepeaterData.length !== repeaterData.length) {
                console.warn("Some images were filtered out due to invalid URLs");
            }

            // Add placeholder if no valid images
            if (validRepeaterData.length === 0) {
                validRepeaterData.push({
                    _id: "placeholder",
                    src: "https://static.wixstatic.com/media/placeholder.jpg"
                });
                console.warn("Using placeholder image due to no valid images");
            }

            // Initialize wishlist states for all images
            const wishlistStates = await Promise.all(
                validRepeaterData.map(() => isProductInWishlist(currentItem._id, userId))
            );

            const { reviews } = await getApprovedReviews(currentItem._id, currentFilter, CONSTANTS.REVIEWS.PAGE_SIZE);
            const avgRating = reviews.length > 0 ? Math.round((reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length) * 10) / 10 : 0;

            $w("#htmlSlideshow").postMessage({
                type: "initSlideshow",
                images: validRepeaterData,
                productIds: new Array(validRepeaterData.length).fill(currentItem._id),
                wishlistStates: wishlistStates,
                avgRating: avgRating,
                isLoggedIn: !!userId
            });

            if (validRepeaterData.length === 0) {
                $w("#htmlSlideshow").collapse();
            } else {
                $w("#htmlSlideshow").expand();
                currentImageIndex = 0;
            }
        } else {
            $w("#productImageRepeater").data = repeaterData;
            $w("#productImageRepeater")[repeaterData.length === 0 ? "collapse" : "expand"]();
            $w("#htmlSlideshow").collapse();
        }

        // Inside $w.onReady -> dataset.onReady -> $w("#htmlSlideshow").onMessage
        $w("#htmlSlideshow").onMessage(async (event) => {
            if (event.data.type === "updateCurrentImage") {
                currentImageIndex = event.data.index;
            } else if (event.data.type === "imageError") {
                console.error("Image failed to load:", event.data.url, event.data.error);
            } else if (event.data.type === "imageUrls") {
                console.log("URLs received:", event.data.urls);
            } else if (event.data.type === "toggleWishlist") {
                const { productId, isWishlisted, index } = event.data;
                if (!productId || index < 0 || index >= repeaterData.length) {
                    console.error("Invalid wishlist toggle data:", { productId, index });
                    $w("#htmlSlideshow").postMessage({
                        type: "wishlistError",
                        error: "Invalid product ID or index",
                        index: index
                    });
                    return;
                }
                try {
                    let newWishlistState;
                    if (userId) {
                        newWishlistState = await toggleWishlist(productId, isWishlisted, userId);
                        await updateWishlistCount(userId); // Added to update count for logged-in users
                    } else {
                        if (isWishlisted) {
                            addToLocalWishlist(productId);
                            newWishlistState = true;
                        } else {
                            removeFromLocalWishlist(productId);
                            newWishlistState = false;
                        }
                        await updateWishlistCount(null); // Update count for logged-out users
                    }
                    $w("#htmlSlideshow").postMessage({
                        type: "updateWishlistState",
                        index: index,
                        isWishlisted: newWishlistState
                    });
                    console.log(`Mobile wishlist toggled for product ${productId}, state: ${newWishlistState}`);
                } catch (error) {
                    console.error("Wishlist toggle failed:", error);
                    $w("#htmlSlideshow").postMessage({
                        type: "wishlistError",
                        error: "Failed to update wishlist",
                        index: index
                    });
                    MessageHandler.showMessage({ message: "Failed to update wishlist.", type: "error" });
                }
            } else if (event.data.type === "scrollToReviews") {
                $w('#reviewsSection').scrollTo();
            } else if (event.data.type === "wishlistError") {
                console.error("Wishlist error:", event.data.error);
                MessageHandler.showMessage({ message: "Failed to update wishlist.", type: "error" });
            }
        });

        images = product.mediaItems.map((item, index) => ({
            _id: (index + 1).toString(),
            name: item.src
        }));

        let productUrl = `https://kk185994.wixstudio.com${URLS.PRODUCT_PAGE.replace('{Slug}', currentItem.slug)}`;
        let productTitle = encodeURIComponent(currentItem.name);
        setupShareButtons(productTitle, productUrl);

        let newPrice = currentItem.discountedPrice;
        let oldPrice = currentItem.price;
        if (newPrice === oldPrice) {
            $w("#oldPriceCont").hide();
            $w("#discountCont").hide();
        } else {
            $w("#oldPriceCont").show();
            $w("#discountCont").show();
            $w("#discount").text = String(oldPrice - newPrice);
        }

        if (currentItem.description) {
            $w("#productDescription").html = currentItem.description;
            $w("#productDescription").show();
        } else {
            $w("#productDescription").collapse();
        }

        setupProductDetailsRepeater(currentItem.productDetails || []);
        setupProductCareRepeater(currentItem.productCare || []);
        setupQuickDetailsRepeater(currentItem.quickDetails || []);

        let allPossibleSizes = CONSTANTS.VARIANTS.AVAILABLESIZES
        let sizeChoices = currentItem.productOptions?.Size?.choices || [];
        let inStockSizes = new Set(sizeChoices
            .filter(choice => choice.inStock)
            .map(choice => choice.value));

        allPossibleSizes.forEach(size => {
            let sizeButton = $w(`#${size}`);

            if (inStockSizes.has(size)) {

                sizeButton.enable();
                sizeButton.onClick(() => handleSizeSelection(sizeButton, size, currentItem));
                sizeButton.customClassList.remove("diagonal-cut");
            } else {
                // Hide the line since we'll use CSS instead
                sizeButton.disable();
                sizeButton.customClassList.add("diagonal-cut");
            }
        });

        $w("#sizeChartButton").onClick(async () => {
            // Always get the latest selectedSize at the moment of click
            const currentItem = $w("#dynamicDataset").getCurrentItem();
            const collectionIds = await getProductCollectionIds(currentItem._id);
            const sizeChoices = currentItem.productOptions?.Size?.choices || [];
            const inStockSizes = new Set(sizeChoices
                .filter(choice => choice.inStock)
                .map(choice => choice.value));

            // Fetch the latest selectedSize here
            let latestSelectedSize = selectedSize;
            // Validate selectedSize
            const validSelectedSize = await inStockSizes.has(latestSelectedSize) ? latestSelectedSize : null;

            // Create a fresh context object with a unique timestamp
            const context = {
                selectedSize: validSelectedSize,
                availableSizes: Array.from(inStockSizes),
                collectionIds,
                key: Date.now() // Unique timestamp to force context refresh
            };

            console.log("Opening lightbox with:", context);
            wixWindow.openLightbox("sizeChartbox", context).then(({ size: selected, wasSelected }) => {
                console.log("Lightbox returned:", { selected, wasSelected });
                if (wasSelected && selected && inStockSizes.has(selected)) {
                    handleSizeSelection($w(`#${selected}`), selected, currentItem);
                }
            });
        });
        await initializeReviews(currentItem);
        await displayReviewImages(currentItem._id);

        if (FORMFACTOR === "Desktop" && $w("#wishlistbutton").type) {
            const productId = currentItem._id;
            let isProcessing = false;
            let isWishlisted = await isProductInWishlist(productId, userId); // Initialize state

            // Initialize wishlist button state
            updateWishlistButtonUI(isWishlisted);

            // Handle wishlist button click
            $w("#wishlistbutton").onClick(async () => {
                if (isProcessing) return;
                isProcessing = true;
                $w("#wishlistbutton").disable();

                try {
                    let newWishlistState;
                    if (userId) {
                        newWishlistState = await toggleWishlist(productId, !isWishlisted, userId);
                        await updateWishlistCount(userId);
                    } else {
                        if (!isWishlisted) {
                            addToLocalWishlist(productId);
                            newWishlistState = true;
                        } else {
                            removeFromLocalWishlist(productId);
                            newWishlistState = false;
                        }
                        await updateWishlistCount(null);
                    }
                    isWishlisted = newWishlistState; // Update isWishlisted for next click
                    updateWishlistButtonUI(newWishlistState);
                    console.log(`Desktop wishlist toggled for product ${productId}, state: ${newWishlistState}`);
                } catch (error) {
                    console.error("Desktop wishlist toggle failed:", error);
                    MessageHandler.showMessage({ message: "Failed to update wishlist.", type: "error" });
                } finally {
                    $w("#wishlistbutton").enable();
                    isProcessing = false;
                }
            });
        }
        if (FORMFACTOR === "Desktop" && $w("#wishlistbutton").type) {
            const productId = currentItem._id;
            let isProcessing = false;
            const isWishlisted = wishlistProductIds.has(productId);
            updateWishlistButtonUI(isWishlisted);

            $w("#wishlistbutton").onClick(createOptimizedDebounce(async () => {
                if (isProcessing) return;
                isProcessing = true;
                $w("#wishlistbutton").disable();

                try {
                    const isAdd = !wishlistProductIds.has(productId);
                    if (isAdd) {
                        wishlistProductIds.add(productId);
                        $w("#wishlistbutton").style.backgroundColor = "#000000";
                        $w("#wishlistbutton").style.color = "#FFFFFF";
                        $w("#wishlistbutton").label = "REMOVE WISHLIST";
                    } else {
                        wishlistProductIds.delete(productId);
                        $w("#wishlistbutton").style.backgroundColor = "#F8F8F8";
                        $w("#wishlistbutton").style.color = "#848484";
                        $w("#wishlistbutton").label = "WISHLIST";
                    }

                    updateWishlistCountImmediate();

                    let success = false;
                    if (userId) {
                        await toggleWishlist(productId, isAdd, userId);
                        const serverProductIds = await getWishlistProductIds(userId);
                        wishlistProductIds = new Set(serverProductIds);
                        success = true;
                    } else {
                        success = isAdd ?
                            addToLocalWishlist(productId) :
                            removeFromLocalWishlist(productId);
                        if (success) {
                            const localWishlist = getLocalWishlist();
                            wishlistProductIds = new Set(localWishlist);
                        }
                    }

                    if (!success) {
                        throw new Error("Wishlist operation failed");
                    }

                    await updateWishlistCount(userId);
                } catch (error) {
                    console.error("Wishlist toggle failed:", error);
                    // Revert UI
                    const isWishlisted = wishlistProductIds.has(productId);
                    updateWishlistButtonUI(isWishlisted);
                    updateWishlistCountImmediate();
                    MessageHandler.showMessage({ message: "Failed to update wishlist.", type: "error" });
                } finally {
                    $w("#wishlistbutton").enable();
                    isProcessing = false;
                }
            }, DEBOUNCE_DELAY));
        }
    });

    $w(GOTOCART_BTN).onClick(() => {
        wixEcomFrontend.openSideCart();
    });

    $w(ADDTOCART_BTN).onClick(async () => {
        console.log("clicked add to cart")
        if (!selectedSize) {
            MessageHandler.showMessage({ message: "Please select a size", type: "error" });
            return;
        }

        let sizeChoices = dataset.getCurrentItem().productOptions?.Size?.choices || [];
        let selectedChoice = sizeChoices.find(choice => choice.value === selectedSize);
        if (!selectedChoice || !selectedChoice.inStock) {
            MessageHandler.showMessage({ message: "Selected size is out of stock", type: "error" });
            return;
        }

        let quantity = selectedQuantity; // Use stored value
        let currentItem = dataset.getCurrentItem();

        gotocartdesign();

        const products = [{
            productId: currentItem._id,
            quantity: quantity,
            options: { choices: { Size: selectedSize } }
        }];

        try {
            const updatedCart = await wixStores.cart.addProducts(products);
            cachedCart = updatedCart;
            if (userID) {
                await publishCartUpdate(userID, { message: { timestamp: Date.now() } });
            }
        } catch (error) {
            console.error("Add to cart error:", error);
            addtocartdesign();
            MessageHandler.showMessage({ message: "Failed to add to cart. Please try again.", type: "error" });
        }
    });

    $w(RATING_INPUT_ID).onChange(async () => {
        const product = dataset.getCurrentItem();
        try {
            const eligibility = await checkReviewEligibility(userId, product._id);
            if ((eligibility.canReview || eligibility.reviewStatus === CONSTANTS.REVIEWS.STATUSES.REJECTED) &&
                $w(RATING_INPUT_ID).value && !$w("#reviewForm").isVisible) {
                $w("#writeReviewButton").show();
                $w("#submitReviewButton").show();
            } else {
                $w("#writeReviewButton").hide();
                $w("#submitReviewButton").show();
            }
        } catch (error) {
            console.error("Error checking review eligibility on rating change:", error);
            $w("#writeReviewButton").hide();
        }
    });

    $w("#reviewText").onInput(() => {
        $w("#submitReviewButton").show();
    });

    $w("#writeReviewButton").onClick(() => {
        $w("#reviewForm").expand();
        $w("#writeReviewButton").hide();
    });

    $w("#submitReviewButton").onClick(async () => {
        await submitReviewForm(dataset.getCurrentItem());
    });

    $w("#reviewFilterDropdown").onChange(async () => {
        currentFilter = $w("#reviewFilterDropdown").value;
        await displayReviews(dataset.getCurrentItem()._id);
        await displayReviewImages(dataset.getCurrentItem()._id);
    });

    $w("#loadMoreReviews").onClick(async () => {
        const product = dataset.getCurrentItem();
        const lightboxData = await wixWindow.openLightbox("allReviewsLightbox", {
            productId: product._id,
            currentFilter,
            userId,
            orderId: matchingOrderId
        });
        if (lightboxData && lightboxData.reviewSubmitted) {
            await checkUserReviewEligibility(product);
            await displayReviews(product._id);
            await displayReviewImages(product._id);
            currentFilter = lightboxData.currentFilter || currentFilter;
            $w("#reviewFilterDropdown").value = currentFilter;
        }
    });

    $w("#loadMoreQuickDetails").onClick(() => {
        isQuickDetailsExpanded = !isQuickDetailsExpanded;
        const product = dataset.getCurrentItem();
        setupQuickDetailsRepeater(product.quickDetails || []);
    });

    wixEcomFrontend.onCartChange(async () => {
        cachedCart = await fetchAndCacheCart();
        updateButtonState(dataset.getCurrentItem());
    });
});



// Helper function to manage arrow states
function toggleArrows(enabled) {
    if ($w("#leftArrow").type) {
        $w("#leftArrow")[enabled ? "enable" : "disable"]();
        console.log(`Left arrow ${enabled ? "enabled" : "disabled"}`);
    }
    if ($w("#rightArrow").type) {
        $w("#rightArrow")[enabled ? "enable" : "disable"]();
        console.log(`Right arrow ${enabled ? "enabled" : "disabled"}`);
    }
}


function updateArrowVisibility() {
    if (FORMFACTOR !== "Desktop") {
        if ($w("#leftArrow").type) $w("#leftArrow").hide();
        if ($w("#rightArrow").type) $w("#rightArrow").hide();
        return;
    }

    if ($w("#leftArrow").type) {
        $w("#leftArrow")[currentStartIndex > 0 ? "show" : "hide"]();
        $w("#leftArrow")[isTopChoicesInitialized ? "enable" : "disable"]();
    }

    if ($w("#rightArrow").type) {
        const canScrollRight = currentStartIndex < Math.max(0, topChoicesData.length - ITEMS_PER_PAGE);
        $w("#rightArrow")[canScrollRight ? "show" : "hide"]();
        $w("#rightArrow")[isTopChoicesInitialized ? "enable" : "disable"]();
    }

    if (topChoicesData.length <= ITEMS_PER_PAGE) {
        if ($w("#leftArrow").type) $w("#leftArrow").hide();
        if ($w("#rightArrow").type) $w("#rightArrow").hide();
    }
}

function scrollRight() {
    if (!isTopChoicesInitialized) {
        console.warn("ScrollRight blocked: topChoicesRepeater not initialized");
        return;
    }

    // Debounce scrolling
    if (debounceTimer) {
        console.log("ScrollRight debounced");
        return;
    }

    // Disable arrows
    toggleArrows(false);

    debounceTimer = setTimeout(() => {
        debounceTimer = null;
        toggleArrows(true); // Re-enable arrows after delay
    }, DEBOUNCE_DELAY);

    const totalItems = topChoicesData.length;
    const maxStartIndex = Math.max(0, totalItems - ITEMS_PER_PAGE);
    if (currentStartIndex < maxStartIndex) {
        currentStartIndex = Math.min(currentStartIndex + ITEMS_PER_PAGE, maxStartIndex);
    }

    $w("#topChoicesRepeater").data = topChoicesData.slice(currentStartIndex, currentStartIndex + ITEMS_PER_PAGE);
    updateArrowVisibility();
    console.log(`Scrolled right to index ${currentStartIndex}, showing items ${currentStartIndex + 1} to ${Math.min(currentStartIndex + ITEMS_PER_PAGE, totalItems)}`);
}

function scrollLeft() {
    if (!isTopChoicesInitialized) {
        console.warn("ScrollLeft blocked: topChoicesRepeater not initialized");
        return;
    }

    // Debounce scrolling
    if (debounceTimer) {
        console.log("ScrollLeft debounced");
        return;
    }

    // Disable arrows
    toggleArrows(false);

    debounceTimer = setTimeout(() => {
        debounceTimer = null;
        toggleArrows(true); // Re-enable arrows after delay
    }, DEBOUNCE_DELAY);

    currentStartIndex = Math.max(0, currentStartIndex - ITEMS_PER_PAGE);
    $w("#topChoicesRepeater").data = topChoicesData.slice(currentStartIndex, currentStartIndex + ITEMS_PER_PAGE);
    updateArrowVisibility();
    console.log(`Scrolled left to index ${currentStartIndex}, showing items ${currentStartIndex + 1} to ${Math.min(currentStartIndex + ITEMS_PER_PAGE, topChoicesData.length)}`);
}
async function fetchAndCacheCart() {
    try {
        const cart = await myGetCurrentCartFunction();
        return cart || { lineItems: [] };
    } catch (error) {
        console.error("Error fetching cart:", error);
        return { lineItems: [] };
    }
}

function isItemInCart(productId, size, cart) {
    if (!cart || !cart.lineItems) return false;
    return cart.lineItems.some(item =>
        item.catalogReference?.catalogItemId === productId &&
        item.catalogReference?.options?.options?.Size === size
    );
}

function handleSizeSelection(sizeButton, size, currentItem) {
    // Log 1: Size selection start
    console.log("[Product Page Log 1] Handling size selection:", { size, previousSize: selectedSize });
    if (selectedSize === size) {
        addtocartdesign();
        sizeButton.style.borderColor = "#000000";
        sizeButton.style.backgroundColor = "#ffffff";
        sizeButton.customClassList.remove("selected");
        selectedSize = null;
        if ($w("#quantityButton").type) {
            $w("#quantityButton").disable();
            selectedQuantity = 1; // Reset quantity
            $w("#quantityButton").label = `Quantity : 0${selectedQuantity}`; // Update display
        }
        // Log 2: Size deselected
        console.log("[Product Page Log 2] Deselected size, new selectedSize:", selectedSize);
    } else {
        if (selectedSize) {
            const prevButton = $w(`#${selectedSize}`);
            prevButton.style.borderColor = "#000000";
            prevButton.style.backgroundColor = "#ffffff";
            prevButton.customClassList.remove("selected");
        }
        selectedSize = size;
        sizeButton.style.borderColor = "#794CEA";
        sizeButton.customClassList.add("selected");
        if ($w("#quantityButton").type) $w("#quantityButton").enable(); // Enable button when size selected
        // Log 3: New size selected
        console.log("[Product Page Log 3] Selected new size:", selectedSize);
        const inCart = isItemInCart(currentItem._id, size, cachedCart);
        inCart ? gotocartdesign() : addtocartdesign();

        // Query allProductsVariants for stock
        wixData.query("allProductsVariants")
            .eq("productId", currentItem._id)
            .eq("choices.Size", size)
            .find()
            .then(result => {
                if (result.items.length > 0) {
                    const variant = result.items[0];
                    const availableQuantity = variant.stock.quantity || 1;
                    const maxQuantity = Math.min(availableQuantity, MAXQUANTITY); // Cap at 10

                    if (selectedQuantity > maxQuantity) {
                        selectedQuantity = 1;

                        console.log("[Product Page Log 5] Reset quantity to 1 due to maxQuantity limit");
                        if ($w("#quantityButton").type) {
                            $w("#quantityButton").label = `Quantity : 0${selectedQuantity}`; // Update display
                        }
                    }
                } else {
                    console.warn("[Product Page Log 4] No variant found for product", currentItem._id, "size", size);

                    selectedQuantity = 1;

                }
                updateButtonState(currentItem);
            })
            .catch(error => {
                console.error("[Product Page Log 5] Error querying allProductsVariants:", error);

                selectedQuantity = 1;
                if ($w("#quantityButton").type) {
                    $w("#quantityButton").label = `Quantity : 0${selectedQuantity}`; // Update display
                }

            });
    }
    updateButtonState(currentItem);
}

function updateButtonState(currentItem) {
    if (selectedSize) {
        const inCart = isItemInCart(currentItem._id, selectedSize, cachedCart);
        if (inCart) {
            // Optionally sync quantity with cart
            const cartItem = cachedCart.lineItems.find(item =>
                item.catalogReference?.catalogItemId === currentItem._id &&
                item.catalogReference?.options?.options?.Size === selectedSize
            );
            if (cartItem && $w("#quantityButton").type) {
                selectedQuantity = cartItem.quantity; // Sync stored quantity
                $w("#quantityButton").label = `Quantity : 0${selectedQuantity}`; // Update display
                $w("#quantityButton").disable();
            }
            gotocartdesign();
        } else {
            addtocartdesign();
        }
    }
}

function gotocartdesign() {
    if ($w(GOTOCART_BTN).type) $w(GOTOCART_BTN).show();

    if ($w(ADDTOCART_BTN).type) $w(ADDTOCART_BTN).disable();
    if ($w("#quantityButton").type) $w("#quantityButton").disable();
}

function addtocartdesign() {

    if ($w(ADDTOCART_BTN).type) $w(ADDTOCART_BTN).enable();
    if ($w(GOTOCART_BTN).type) $w(GOTOCART_BTN).hide();
    if ($w("#quantityButton").type) $w("#quantityButton").enable();
}

function setupShareButtons(productTitle, productUrl) {
    function openShareLink(url) {
        wixLocation.to(url);
    }

    // $w("#shareWhatsapp").onClick(() => {
    //     let whatsappUrl = `https://wa.me/?text=${productTitle}%20${productUrl}`;
    //     openShareLink(whatsappUrl);
    // });

    // $w("#shareFacebook").onClick(() => {
    //     let facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${productUrl}`;
    //     openShareLink(facebookUrl);
    // });

    // $w("#shareTwitter").onClick(() => {
    //     let twitterUrl = `https://twitter.com/intent/tweet?text=${productTitle}&url=${productUrl}`;
    //     openShareLink(twitterUrl);
    // });

    // $w("#shareLinkedIn").onClick(() => {
    //     let linkedinUrl = `https://www.linkedin.com/shareArticle?mini=true&url=${productUrl}&title=${productTitle}`;
    //     openShareLink(linkedinUrl);
    // });

    // $w("#shareTelegram").onClick(() => {
    //     let telegramUrl = `https://t.me/share/url?url=${productUrl}&text=${productTitle}`;
    //     openShareLink(telegramUrl);
    // });
}

function setupProductDetailsRepeater(productDetails) {
    $w("#productDetailsRepeater").onItemReady(($item, itemData) => {
        if (itemData.title) {
            $item("#detailHeading").text = itemData.title;
            $item("#detailHeading").show();
        } else {
            $item("#detailHeading").collapse();
        }
        if (itemData.description) {
            $item("#detailDescription").html = itemData.description;
            $item("#detailDescription").show();
        } else {
            $item("#detailDescription").collapse();
        }
    });

    const repeaterData = productDetails.map((item, index) => ({
        _id: (index + 1).toString(),
        title: item.title,
        description: item.description
    }));

    $w("#productDetailsRepeater").data = repeaterData;

    if (repeaterData.length === 0) {
        $w("#productDetailsRepeater").collapse();
    } else {
        $w("#productDetailsRepeater").show();
    }
}

function setupProductCareRepeater(productCare) {
    $w("#productCareRepeater").onItemReady(($item, itemData) => {
        if (itemData.title) {
            $item("#careHeading").text = itemData.title;
            $item("#careHeading").show();
        } else {
            $item("#careHeading").collapse();
        }
        if (itemData.description) {
            $item("#careDescription").html = itemData.description;
            $item("#careDescription").show();
        } else {
            $item("#careDescription").collapse();
        }
    });

    const repeaterData = productCare.map((item, index) => ({
        _id: (index + 1).toString(),
        title: item.title,
        description: item.description
    }));

    $w("#productCareRepeater").data = repeaterData;

    if (repeaterData.length === 0) {
        $w("#productCareRepeater").collapse();
    } else {
        $w("#productCareRepeater").show();
    }
}

function setupQuickDetailsRepeater(quickDetails) {
    $w("#quickDetailsRepeater").onItemReady(($item, itemData) => {
        if (itemData.title) {
            $item("#quickDetailHeading").text = itemData.title;
            $item("#quickDetailHeading").show();
        } else {
            $item("#quickDetailHeading").collapse();
        }
        if (itemData.description) {
            $item("#quickDetailDescription").text = itemData.description;
            $item("#quickDetailDescription").show();
        } else {
            $item("#quickDetailDescription").collapse();
        }
    });

    // Convert object to array for repeater
    const maxItems = 6;
    const repeaterData = Object.entries(quickDetails || {}).map(([title, description], index) => ({
        _id: (index + 1).toString(),
        title,
        description
    }));

    const displayItems = isQuickDetailsExpanded ? repeaterData : repeaterData.slice(0, maxItems);
    $w("#quickDetailsRepeater").data = displayItems;

    if (repeaterData.length === 0) {
        $w("#quickDetailsRepeater").collapse();
        $w("#loadMoreQuickDetails").hide();
    } else {
        $w("#quickDetailsRepeater").show();
        if (repeaterData.length > maxItems) {
            $w("#loadMoreQuickDetails").label = isQuickDetailsExpanded ? "Show Less" : "Load More";
            $w("#loadMoreQuickDetails").show();
        } else {
            $w("#loadMoreQuickDetails").hide();
        }
    }
}

async function initializeReviews(product) {
    if (!userId) {
        $w(RATING_INPUT_ID).hide();
        $w("#submitReviewButton").hide();
        $w("#writeReviewButton").hide();
        $w("#reviewStatusMessage").hide();
        $w("#reviewForm").collapse();
        $w("#approvedReviewForm").collapse();
    } else {
        await checkUserReviewEligibility(product);
    }
    await displayReviews(product._id);
}

async function checkUserReviewEligibility(product) {
    try {
        const eligibility = await checkReviewEligibility(userId, product._id);
        matchingOrderId = eligibility.orderId;

        if (eligibility.reviewStatus === CONSTANTS.REVIEWS.STATUSES.PENDING) {
            $w("#reviewStatusMessage").text = "Your review is under review.";
            $w("#reviewStatusMessage").show();
            $w(RATING_INPUT_ID).hide();
            $w("#submitReviewButton").hide();
            $w("#writeReviewButton").hide();
            $w("#reviewForm").collapse();
            $w("#approvedReviewForm").collapse();
            $w("#reviewImagePlaceholder").collapse();
            $w("#reviewImageHtml").collapse();
        } else if (eligibility.reviewStatus === CONSTANTS.REVIEWS.STATUSES.REJECTED) {
            $w("#reviewStatusMessage").text = "Your review was rejected. Please revise and resubmit.";
            $w("#reviewStatusMessage").show();
            $w(RATING_INPUT_ID).show();
            $w("#submitReviewButton").hide();
            $w("#writeReviewButton").hide(); // Hide by default, form is expanded
            $w("#reviewForm").expand();
            $w("#approvedReviewForm").collapse();

            const rejectedReview = await getRejectedReview(userId, product._id, eligibility.orderId);
            if (rejectedReview) {
                $w(RATING_INPUT_ID).value = rejectedReview.rating;
                $w("#reviewText").value = rejectedReview.reviewText || "";
                if (rejectedReview.imageUrl) {
                    $w("#reviewImagePlaceholder").src = rejectedReview.imageUrl;
                    $w("#reviewImagePlaceholder").expand();
                    $w("#reviewImageHtml").postMessage({
                        type: "initUpload",
                        hasImage: true,
                        label: "Change photo review"
                    });
                    $w("#reviewImageHtml").expand();
                } else {
                    $w("#reviewImagePlaceholder").collapse();
                    $w("#reviewImageHtml").postMessage({
                        type: "initUpload",
                        hasImage: false,
                        label: "Add a photo review"
                    });
                    $w("#reviewImageHtml").expand();
                }
            }
        } else if (eligibility.reviewStatus === CONSTANTS.REVIEWS.STATUSES.APPROVED) {
            const approvedReview = await wixData.query(CONSTANTS.COLLECTIONS.REVIEWS)
                .eq("userId", userId)
                .eq("productId", product._id)
                .eq("status", CONSTANTS.REVIEWS.STATUSES.APPROVED)
                .find();

            if (approvedReview.items.length > 0) {
                const review = approvedReview.items[0];
                $w("#usersApprovedRating").rating = review.rating;
                $w("#approvedReviewText").text = review.reviewText || "";
                if (review.imageUrl) {
                    $w("#approvedReviewImage").src = review.imageUrl;
                    $w("#approvedReviewImage").show();
                } else {
                    $w("#approvedReviewImage").hide();
                }
                $w("#approvedReviewForm").expand();
                $w("#reviewStatusMessage").hide();
                $w(RATING_INPUT_ID).hide();
                $w("#submitReviewButton").hide();
                $w("#writeReviewButton").hide();
                $w("#reviewForm").collapse();
                $w("#reviewImagePlaceholder").collapse();
                $w("#reviewImageHtml").collapse();
            }
        } else if (eligibility.canReview) {
            $w("#reviewStatusMessage").hide();
            $w(RATING_INPUT_ID).show();
            $w("#submitReviewButton").hide();
            $w("#writeReviewButton").hide(); // Hide by default on page load
            $w("#reviewForm").collapse();
            $w("#approvedReviewForm").collapse();
            $w("#reviewImagePlaceholder").collapse();
            $w("#reviewImageHtml").postMessage({
                type: "initUpload",
                hasImage: false,
                label: "Add a photo review"
            });
            $w("#reviewImageHtml").expand();
        } else {
            $w(RATING_INPUT_ID).hide();
            $w("#submitReviewButton").hide();
            $w("#writeReviewButton").hide();
            $w("#reviewStatusMessage").hide();
            $w("#reviewForm").collapse();
            $w("#approvedReviewForm").collapse();
            $w("#reviewImagePlaceholder").collapse();
            $w("#reviewImageHtml").collapse();
        }
    } catch (error) {
        console.error("Error checking review eligibility:", error);
        MessageHandler.showMessage({ message: "Failed to load review section.", type: "error" });
        $w(RATING_INPUT_ID).hide();
        $w("#submitReviewButton").hide();
        $w("#writeReviewButton").hide();
        $w("#reviewStatusMessage").hide();
        $w("#reviewForm").collapse();
        $w("#approvedReviewForm").collapse();
        $w("#reviewImagePlaceholder").collapse();
        $w("#reviewImageHtml").collapse();
    }
}
async function displayReviews(productId) {
    try {
        const { reviews, hasNext } = await getApprovedReviews(productId, currentFilter, CONSTANTS.REVIEWS.PAGE_SIZE);
        const filteredReviews = reviews.filter(review => review.reviewText || review.imageUrl);

        if (reviews.length > 0) {
            const avgRating = reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length;
            $w("#averageRating").text = String(Math.round(avgRating * 2) / 2);
            $w("#totalReviews").text = `${reviews.length} Reviews`;

            const ratingCounts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
            reviews.forEach(review => {
                const rating = Math.round(review.rating);
                if (rating >= 1 && rating <= 5) {
                    ratingCounts[rating]++;
                }
            });

            [1, 2, 3, 4, 5].forEach(rating => {
                const progressBar = $w(`#progressBar${rating}`);
                progressBar.targetValue = reviews.length;
                progressBar.value = ratingCounts[rating];
            });
        } else {
            $w("#averageRating").text = "0";
            $w("#totalReviews").text = "No reviews yet";
            [1, 2, 3, 4, 5].forEach(rating => {
                const progressBar = $w(`#progressBar${rating}`);
                progressBar.targetValue = 1;
                progressBar.value = 0;
            });
        }

        $w("#reviewsRepeater").onItemReady(($item, itemData) => {
            $item("#reviewerName").text = itemData.customerName || "Anonymous";
            $item("#reviewRating").rating = itemData.rating;
            $item("#reviewTextDisplay").text = itemData.reviewText || "";
            if (itemData.imageUrl) {
                $item("#reviewImage").src = itemData.imageUrl;
                $item("#reviewImage").show();
                $item("#reviewImage").onClick(() => {
                    wixWindow.openLightbox("imageGalleryLightbox", {
                        review: itemData,
                        showNavigation: false,
                        productId
                    });
                });
            } else {
                $item("#reviewImage").hide();
            }
            $item("#reviewDate").text = new Date(itemData._createdDate).toLocaleDateString("en-IN", {
                year: "numeric",
                month: "long",
                day: "numeric"
            });
        });

        $w("#reviewsRepeater").data = filteredReviews;

        const totalFilteredCount = (await wixData.query(CONSTANTS.COLLECTIONS.REVIEWS)
            .eq("productId", productId)
            .eq("status", CONSTANTS.REVIEWS.STATUSES.APPROVED)
            .hasSome("reviewText", [""])
            .or(wixData.query(CONSTANTS.COLLECTIONS.REVIEWS)
                .eq("productId", productId)
                .eq("status", CONSTANTS.REVIEWS.STATUSES.APPROVED)
                .ne("imageUrl", ""))
            .count());
        $w("#loadMoreReviews")[totalFilteredCount > CONSTANTS.REVIEWS.PAGE_SIZE ? "show" : "hide"]();
    } catch (error) {
        console.error("Error displaying reviews:", error);
        MessageHandler.showMessage({ message: "Failed to load reviews.", type: "error" });
    }
}

async function displayReviewImages(productId) {
    try {
        const maxImages = 5;
        const { reviews, totalCount } = await getApprovedReviewsWithImages(productId, currentFilter, maxImages);

        $w("#reviewImagesRepeater").onItemReady(($item, itemData) => {
            $item("#reviewImagePreview").src = itemData.imageUrl;
            $item("#reviewImagePreview").onClick(() => {
                wixWindow.openLightbox("imageGalleryLightbox", {
                    review: itemData,
                    showNavigation: false,
                    productId
                });
            });
        });

        $w("#reviewImagesRepeater").data = reviews;

        if (totalCount > maxImages) {
            $w("#moreImagesText").text = `+${totalCount - maxImages} more images`;
            $w("#reviewImagesRepeater").show();
            $w("#moreImagesText").onClick(() => {
                wixWindow.openLightbox("imageGalleryLightbox", {
                    productId,
                    currentFilter,
                    showNavigation: true
                });
            });
        } else {
            $w("#moreImagesText").hide();
        }

        if (reviews.length === 0) {
            $w("#reviewImagesRepeater").hide();
            $w("#moreImagesText").hide();
        } else {
            $w("#reviewImagesRepeater").show();
        }
    } catch (error) {
        console.error("Error displaying review images:", error);
        MessageHandler.showMessage({ message: "Failed to load review images.", type: "error" });
        $w("#reviewImagesRepeater").hide();
        $w("#moreImagesText").hide();
    }
}

async function submitReviewForm(product) {
    try {
        $w("#submitReviewButton").disable();

        const rating = $w(RATING_INPUT_ID).value;
        if (!rating || rating < CONSTANTS.REVIEWS.RATING_MIN || rating > CONSTANTS.REVIEWS.RATING_MAX) {
            MessageHandler.showMessage({ message: CONSTANTS.ERROR_MESSAGES.REVIEW_INVALID_RATING, type: "error", timeout: 3000 });
            $w("#submitReviewButton").enable();
            return;
        }

        let reviewText = $w("#reviewText").value;
        if (reviewText.length > CONSTANTS.REVIEWS.MAX_REVIEW_LENGTH) {
            MessageHandler.showMessage({ message: CONSTANTS.ERROR_MESSAGES.REVIEW_TEXT_TOO_LONG, type: "error", timeout: 3000 });
            $w("#submitReviewButton").enable();
            return;
        }

        let imageUrl = "";
        if ($w("#reviewImagePlaceholder").isVisible) {
            imageUrl = $w("#reviewImagePlaceholder").src;
            // Check data URL size (approx 2MB limit for Wix Data, accounting for base64 overhead)
            if (imageUrl.length > 2 * 1024 * 1024 * 1.33) {
                MessageHandler.showMessage({ message: "Image data is too large. Please select a smaller image.", type: "error", timeout: 3000 });
                $w("#submitReviewButton").enable();
                return;
            }
        }

        const eligibility = await checkReviewEligibility(userId, product._id);
        if (!eligibility.canReview && eligibility.reviewStatus !== CONSTANTS.REVIEWS.STATUSES.REJECTED) {
            MessageHandler.showMessage({ message: eligibility.reviewStatus ? "Review status: " + eligibility.reviewStatus : CONSTANTS.ERROR_MESSAGES.REVIEW_NOT_DELIVERED, type: "error", timeout: 3000 });
            $w("#submitReviewButton").enable();
            return;
        }

        if (eligibility.reviewStatus === CONSTANTS.REVIEWS.STATUSES.REJECTED) {
            const rejectedReview = await getRejectedReview(userId, product._id, eligibility.orderId);
            if (rejectedReview) {
                reviewText = reviewText || rejectedReview.reviewText || "";
                imageUrl = imageUrl || rejectedReview.imageUrl || "";
            }
        }

        const reviewData = {
            userId,
            orderId: eligibility.orderId,
            productId: product._id,
            rating,
            reviewText,
            imageUrl,
            customerName: "Anonymous"
        };

        const result = await submitReview(reviewData);
        if (result.success) {
            MessageHandler.showMessage({
                message: reviewText || imageUrl ? "Review submitted successfully! It's under review." : "Rating submitted successfully!",
                type: "success",
                timeout: 3000
            });
            resetReviewForm();
            $w("#reviewStatusMessage").text = reviewText || imageUrl ? "Your review is under review." : "Your rating has been approved.";
            $w("#reviewStatusMessage").show();
            await checkUserReviewEligibility(product);
            await displayReviews(product._id);
            await displayReviewImages(product._id);
        } else {
            MessageHandler.showMessage({ message: result.message, type: "error", timeout: 3000 });
        }
    } catch (error) {
        console.error("Error submitting review:", error);
        MessageHandler.showMessage({ message: "Failed to submit review. Please try again.", type: "error", timeout: 3000 });
    } finally {
        $w("#submitReviewButton").enable();
    }
}

function resetReviewForm() {
    $w(RATING_INPUT_ID).value = null;
    $w("#reviewText").value = "";
    $w("#reviewImagePlaceholder").collapse();
    $w("#reviewImageHtml").postMessage({
        type: "initUpload",
        hasImage: false,
        label: "Add a photo review"
    });
    $w("#reviewImageHtml").expand();
    $w("#reviewForm").collapse();
    $w("#submitReviewButton").hide();
    if (!$w(RATING_INPUT_ID).value && !$w("#reviewForm").isVisible) {
        $w("#writeReviewButton").show();
    } else {
        $w("#writeReviewButton").hide();
    }
}
async function isProductInWishlist(productId, userId) {
    try {
        if (userId) {
            const result = await wixData.query("WishList")
                .eq("userid", userId)
                .find();
            return result.items.length > 0 && result.items[0].productIds.includes(productId);
        } else {
            const wishlist = JSON.parse(local.getItem("localWishlist") || "[]");
            return wishlist.includes(productId);
        }
    } catch (error) {
        console.error("Error checking wishlist:", error);
        return false;
    }
}


function updateWishlistButtonUI(isWishlisted) {
    if (isWishlisted) {
        $w("#wishlistbutton").style.backgroundColor = "#000000"; // Filled heart
        $w("#wishlistbutton").style.color = "#FFFFFF"; // White icon
        $w("#wishlistbutton").label = "REMOVE WISHLIST";
    } else {
        $w("#wishlistbutton").style.backgroundColor = "#F8F8F8"; // Empty heart
        $w("#wishlistbutton").style.color = "#848484"; // Gray icon
        $w("#wishlistbutton").label = "WISHLIST";
    }
}

$w('#checkeddButton').onClick(async (event) => {
    const pincode = $w("#deliveryPincodeInput").value.trim();
    
    // Validate pincode
    if (!pincode || !/^[0-9]{6}$/.test(pincode)) {
        $w("#estimatedDeliveryDate").text = "Please enter a valid 6-digit pincode";
        $w("#estimatedDeliveryDate").style.color = 'rgba(246,85,35,1)';
        $w("#estimatedDeliveryDate").expand();
        $w("#estimatedDeliveryDate").customClassList.add("eddstackcss");
        $w("#expressEstimatedDeliveryDate").collapse();
        return;
    }

    try {
        // Call checkPincodeTAT with mot='all' and destinationPincode as the user-entered pincode
        const result = await checkPincodeTAT("700051", pincode, "all");

        if (result.success && result.data) {
            const { S_tat_days, E_tat_days } = result.data;

            // Handle Standard Delivery (S_tat_days)
            if (S_tat_days !== null) {
                $w("#estimatedDeliveryDate").text = `Delivery by: ${S_tat_days} days`;
                $w("#estimatedDeliveryDate").style.color = 'rgba(2,181,29,1)';
                $w("#estimatedDeliveryDate").expand();
                $w("#estimatedDeliveryDate").customClassList.add("eddstackcss");
            } else {
                $w("#estimatedDeliveryDate").collapse();
                $w("#estimatedDeliveryDate").customClassList.remove("eddstackcss");
            }

            // Handle Express Delivery (E_tat_days)
            if (E_tat_days !== null) {
                $w("#expressEstimatedDeliveryDate").text = `Fastest Delivery by: ${E_tat_days} days`;
                $w("#expressEstimatedDeliveryDate").style.color = 'rgba(2,181,29,1)';
                $w("#expressEstimatedDeliveryDate").expand();
                $w("#expressEstimatedDeliveryDate").customClassList.add("expresseddstackcss");
            } else {
                $w("#expressEstimatedDeliveryDate").collapse();
                $w("#expressEstimatedDeliveryDate").customClassList.remove("expresseddstackcss");
            }

            // If no delivery options are available
            if (S_tat_days === null && E_tat_days === null) {
                $w("#estimatedDeliveryDate").text = "No delivery available at your location";
                $w("#estimatedDeliveryDate").style.color = 'rgba(246,85,35,1)';
                $w("#estimatedDeliveryDate").expand();
                $w("#estimatedDeliveryDate").customClassList.add("eddstackcss");
                $w("#expressEstimatedDeliveryDate").collapse();
            }
        } else {
            // Handle error case
            $w("#estimatedDeliveryDate").text = result.error || "Failed to check delivery date. Please try again.";
            $w("#estimatedDeliveryDate").style.color = 'rgba(246,85,35,1)';
            $w("#estimatedDeliveryDate").expand();
            $w("#estimatedDeliveryDate").customClassList.add("eddstackcss");
            $w("#expressEstimatedDeliveryDate").collapse();
        }
    } catch (error) {
        console.error("Error fetching delivery date:", error);
        $w("#estimatedDeliveryDate").text = "Failed to check delivery date. Please try again.";
        $w("#estimatedDeliveryDate").style.color = 'rgba(246,85,35,1)';
        $w("#estimatedDeliveryDate").expand();
        $w("#estimatedDeliveryDate").customClassList.add("eddstackcss");
        $w("#expressEstimatedDeliveryDate").collapse();
    }
});
// Helper function to manage similar products arrow states
function toggleSimilarArrows(enabled) {
    if ($w("#similarLeftArrow").type) {
        $w("#similarLeftArrow")[enabled ? "enable" : "disable"]();
        console.log(`Similar Left arrow ${enabled ? "enabled" : "disabled"}`);
    }
    if ($w("#similarRightArrow").type) {
        $w("#similarRightArrow")[enabled ? "enable" : "disable"]();
        console.log(`Similar Right arrow ${enabled ? "enabled" : "disabled"}`);
    }
}


function updateSimilarArrowVisibility() {
    if (FORMFACTOR !== "Desktop") {
        if ($w("#similarLeftArrow").type) $w("#similarLeftArrow").hide();
        if ($w("#similarRightArrow").type) $w("#similarRightArrow").hide();
        return;
    }

    if ($w("#similarLeftArrow").type) {
        $w("#similarLeftArrow")[similarStartIndex > 0 ? "show" : "hide"]();
        $w("#similarLeftArrow")[isSimilarProductsInitialized ? "enable" : "disable"]();
    }

    if ($w("#similarRightArrow").type) {
        const canScrollRight = similarStartIndex < Math.max(0, similarProductsData.length - ITEMS_PER_PAGE);
        $w("#similarRightArrow")[canScrollRight ? "show" : "hide"]();
        $w("#similarRightArrow")[isSimilarProductsInitialized ? "enable" : "disable"]();
    }

    if (similarProductsData.length <= ITEMS_PER_PAGE) {
        if ($w("#similarLeftArrow").type) $w("#similarLeftArrow").hide();
        if ($w("#similarRightArrow").type) $w("#similarRightArrow").hide();
    }
}

function scrollSimilarRight() {
    if (!isSimilarProductsInitialized) {
        console.warn("ScrollSimilarRight blocked: similarProductsRepeater not initialized");
        return;
    }

    // Debounce scrolling
    if (similarDebounceTimer) {
        console.log("ScrollSimilarRight debounced");
        return;
    }

    // Disable arrows
    toggleSimilarArrows(false);

    similarDebounceTimer = setTimeout(() => {
        similarDebounceTimer = null;
        toggleSimilarArrows(true); // Re-enable arrows after delay
    }, DEBOUNCE_DELAY);

    const totalItems = similarProductsData.length;
    const maxStartIndex = Math.max(0, totalItems - ITEMS_PER_PAGE);
    if (similarStartIndex < maxStartIndex) {
        similarStartIndex = Math.min(similarStartIndex + ITEMS_PER_PAGE, maxStartIndex);
    }

    $w("#similarProductsRepeater").data = similarProductsData.slice(similarStartIndex, similarStartIndex + ITEMS_PER_PAGE);
    updateSimilarArrowVisibility();
    console.log(`Scrolled similar products right to index ${similarStartIndex}, showing items ${similarStartIndex + 1} to ${Math.min(similarStartIndex + ITEMS_PER_PAGE, totalItems)}`);
}

function scrollSimilarLeft() {
    if (!isSimilarProductsInitialized) {
        console.warn("ScrollSimilarLeft blocked: similarProductsRepeater not initialized");
        return;
    }

    // Debounce scrolling
    if (similarDebounceTimer) {
        console.log("ScrollSimilarLeft debounced");
        return;
    }

    // Disable arrows
    toggleSimilarArrows(false);

    similarDebounceTimer = setTimeout(() => {
        similarDebounceTimer = null;
        toggleSimilarArrows(true); // Re-enable arrows after delay
    }, DEBOUNCE_DELAY);

    similarStartIndex = Math.max(0, similarStartIndex - ITEMS_PER_PAGE);
    $w("#similarProductsRepeater").data = similarProductsData.slice(similarStartIndex, similarStartIndex + ITEMS_PER_PAGE);
    updateSimilarArrowVisibility();
    console.log(`Scrolled similar products left to index ${similarStartIndex}, showing items ${similarStartIndex + 1} to ${Math.min(similarStartIndex + ITEMS_PER_PAGE, similarProductsData.length)}`);
}

function transformImageUrl(src) {
    if (src?.startsWith("wix:image://")) {
        const match = src.match(/wix:image:\/\/v1\/(.+?)(?:\/[^#]+)?(?:#.*)?$/);
        if (match && match[1]) {
            return `https://static.wixstatic.com/media/${match[1]}`;
        }
    }
    return src || "";
}

async function getProductCollectionIds(productId) {
    try {
        // Replace 'Products' with your actual collection name
        const product = await wixData.query("allProducts")
            .eq("_id", productId)
            .include("collections")
            .find();

        if (!product.items.length) {
            console.warn("[Product Page Log] No product found for ID:", productId);
            return [];
        }

        const collections = product.items[0].collections || [];
        const collectionIds = collections.map(collection => collection._id).filter(id => id);
        console.log("[Product Page Log] Fetched collection IDs:", collectionIds);
        return collectionIds;
    } catch (error) {
        console.error("[Product Page Log] Error fetching product collections:", error);
        return [];
    }
}


async function initializeWishlistData(userId) {
    try {
        let productIds;
        if (userId) {
            productIds = await getWishlistProductIds(userId);
        } else {
            productIds = getLocalWishlist();
        }
        wishlistProductIds = new Set(productIds);
    } catch (error) {
        console.error("Error initializing wishlist data:", error);
        wishlistProductIds = new Set();
    }
}

function createWishlistHandler(item, itemData, isAdd, repeaterId) {
    return createOptimizedDebounce(async () => {
        if (!itemData.productId) {
            console.error("Missing productId for item:", itemData);
            MessageHandler.showMessage({
                message: "Failed to process wishlist operation: Invalid product ID.",
                type: "error"
            });
            return;
        }

        const productId = itemData.productId;
        const wishlistButton1 = item(`#${repeaterId}Wishlist1`);
        const wishlistButton2 = item(`#${repeaterId}Wishlist2`);

        // Immediate UI feedback
        if (isAdd) {
            wishlistButton1.hide();
            wishlistButton2.show();
            wishlistProductIds.add(productId);
        } else {
            wishlistButton2.hide();
            wishlistButton1.show();
            wishlistProductIds.delete(productId);
        }

        updateWishlistCountImmediate();

        try {
            let success = false;

            if (userId) {
                await toggleWishlist(productId, isAdd, userId);
                const serverProductIds = await getWishlistProductIds(userId);
                wishlistProductIds = new Set(serverProductIds);
                success = true;
            } else {
                success = isAdd ?
                    addToLocalWishlist(productId) :
                    removeFromLocalWishlist(productId);

                if (success) {
                    const localWishlist = getLocalWishlist();
                    wishlistProductIds = new Set(localWishlist);
                }
            }

            if (!success) {
                throw new Error("Wishlist operation failed");
            }

            await updateWishlistButtons(productId, isAdd);
            await updateWishlistCount(userId);

        } catch (error) {
            console.error("Error in wishlist operation for productId", productId, error);

            // Revert UI
            if (isAdd) {
                wishlistButton2.hide();
                wishlistButton1.show();
                wishlistProductIds.delete(productId);
            } else {
                wishlistButton1.hide();
                wishlistButton2.show();
                wishlistProductIds.add(productId);
            }

            updateWishlistCountImmediate();
            MessageHandler.showMessage({
                message: `Failed to ${isAdd ? 'add to' : 'remove from'} wishlist.`,
                type: "error"
            });

            await updateAllRepeaters();
        }
    }, DEBOUNCE_DELAY);
}

async function updateWishlistButtons(productId, isAdd) {
    try {
        const repeaters = [
            { id: "topChoicesRepeater", prefix: "topChoices" },
            { id: "similarProductsRepeater", prefix: "similarChoices" }
        ];

        for (const { id, prefix } of repeaters) {
            if (!$w(`#${id}`).type) continue;

            $w(`#${id}`).forEachItem(($item, itemData) => {
                if (itemData.productId === productId) {
                    const wishlistButton1 = $item(`#${prefix}Wishlist1`);
                    const wishlistButton2 = $item(`#${prefix}Wishlist2`);

                    if (wishlistButton1?.type && wishlistButton2?.type) {
                        if (isAdd) {
                            wishlistButton1.hide();
                            wishlistButton2.show();
                        } else {
                            wishlistButton1.show();
                            wishlistButton2.hide();
                        }
                    }
                }
            });
        }
    } catch (error) {
        console.error(`Error updating wishlist buttons for productId ${productId}:`, error);
        await updateAllRepeaters();
    }
}

async function updateAllRepeaters() {
    try {
        const repeaters = ["topChoicesRepeater", "similarProductsRepeater"];
        for (const repeaterId of repeaters) {
            if ($w(`#${repeaterId}`).type) {
                const currentData = $w(`#${repeaterId}`).data;
                $w(`#${repeaterId}`).data = [];
                await new Promise(resolve => setTimeout(resolve, 0));
                $w(`#${repeaterId}`).data = currentData;
            }
        }
    } catch (error) {
        console.error("Error updating repeaters:", error);
    }
}
async function fetchRepeaterData(productId) {
    const fetchers = [
        { key: CACHE_KEYS.TOP_CHOICES, fetch: () => fetchTopChoices(15), data: topChoicesData },
        { key: `${CACHE_KEYS.SIMILAR_PRODUCTS}${productId}`, fetch: () => fetchSimilarProducts(productId, 15), data: similarProductsData }
    ];

    const promises = fetchers.map(async ({ key, fetch, data }) => {
        try {
            let cachedData = await getCachedData(key);
            if (cachedData) {
                data.splice(0, data.length, ...cachedData);
                console.log(`Loaded ${data.length} items from cache for ${key}`);
                return;
            }
            const fetchedData = await fetch();
            data.splice(0, data.length, ...fetchedData);
            console.log(`Fetched and cached ${data.length} items for ${key}`);
        } catch (error) {
            console.error(`Error fetching data for ${key}:`, error);
            data.splice(0, data.length);
        }
    });

    await Promise.all(promises);
}

async function updateWishlistCount(userId) {
    try {
        let totalItems = wishlistProductIds.size;
        if (userId) {
            try {
                const serverProductIds = await getWishlistProductIds(userId);
                if (serverProductIds.length !== totalItems) {
                    wishlistProductIds = new Set(serverProductIds);
                    totalItems = serverProductIds.length;
                    await updateWishlistButtons(null, null);
                }
            } catch (serverError) {
                console.warn("Server verification failed, using cached count:", serverError);
            }
        } else {
            totalItems = getLocalWishlistCount();
            wishlistProductIds = new Set(getLocalWishlist());
        }

        if ($w("#wishlistcount").type) {
            $w("#wishlistcount").text = totalItems.toString();
        }
        if ($w("#box23").type) {
            $w("#box23")[totalItems > 0 ? "show" : "hide"]();
        }
        console.log("Wishlist count updated:", totalItems);
    } catch (error) {
        console.error("Error updating wishlist count:", error);
        if ($w("#wishlistcount").type) {
            $w("#wishlistcount").text = "0";
        }
        if ($w("#box23").type) {
            $w("#box23").hide();
        }
    }
}

function updateWishlistCountImmediate() {
    const count = wishlistProductIds.size;
    if ($w("#wishlistcount").type) {
        $w("#wishlistcount").text = count.toString();
    }
    if ($w("#box23").type) {
        $w("#box23")[count > 0 ? "show" : "hide"]();
    }
}

function initializeRepeaters() {
    const repeaters = [
        {
            sectionId: "topChoicesSection",
            repeaterId: "topChoicesRepeater",
            leftArrowId: "leftArrow",
            rightArrowId: "rightArrow",
            data: topChoicesData,
            startIndex: topChoicesStartIndex,
            prefix: "topChoices"
        },
        {
            sectionId: "similarProductsSection",
            repeaterId: "similarProductsRepeater",
            leftArrowId: "similarLeftArrow",
            rightArrowId: "similarRightArrow",
            data: similarProductsData,
            startIndex: similarStartIndex,
            prefix: "similarChoices"
        }
    ];

    repeaters.forEach((repeater) => {
        const { sectionId, repeaterId, leftArrowId, rightArrowId, data, prefix } = repeater;
        let { startIndex } = repeater;

        if (!$w(`#${repeaterId}`).type) {
            console.warn(`Repeater #${repeaterId} not found`);
            return;
        }

        if (!data.length) {
            console.warn(`No products found for ${repeaterId}`);
            $w(`#${sectionId}`).hide();
            $w(`#${leftArrowId}`)?.hide();
            $w(`#${rightArrowId}`)?.hide();
            return;
        }

$w(`#${repeaterId}`).onItemReady(($item, itemData, index) => {
    try {
        $item(`#${prefix}ProductName`).text = itemData.name?.split("|")[0]?.trim() || '';

        const discountedPrice = itemData.discountedPrice;
        const discountedPriceText = $item(`#${prefix === 'topChoices' ? 'topChoicesDiscountedPrice' : 'similarDiscountedPrice'}`);
        if (discountedPriceText?.type && discountedPrice != null) {
            discountedPriceText.text = itemData.formattedDiscountedPrice || `${discountedPrice.toFixed(2)}`;
            discountedPriceText.show();
        } else {
            discountedPriceText?.hide();
        }

        const mediaItems = itemData.mediaItems || [];
        const image1 = $item(`#${prefix}Image${prefix === 'topChoices' ? '2' : '1'}`);
        const image2 = $item(`#${prefix}Image${prefix === 'topChoices' ? '1' : '2'}`);

        if (image1?.type && mediaItems[prefix === 'topChoices' ? 1 : 0]?.src) {
            image1.src = transformImageUrl(mediaItems[prefix === 'topChoices' ? 1 : 0].src);
            image1.show();
        } else {
            image1?.hide();
        }

        if (image2?.type && mediaItems[prefix === 'topChoices' ? 0 : 1]?.src) {
            image2.src = transformImageUrl(mediaItems[prefix === 'topChoices' ? 0 : 1].src);
            image2.show();
        } else {
            image2?.hide();
        }

        if (FORMFACTOR === "Desktop") {
            const allPossibleSizes = CONSTANTS.VARIANTS.AVAILABLESIZES || [];
            // Use productOptions.Size.choices for both repeaters
            const availableSizes = new Set(
                itemData.productOptions?.Size?.choices?.filter(size => size?.inStock)?.map(size => size.value) || []
            );

            allPossibleSizes.forEach(size => {
                const sizeButton = $item(`#${prefix === 'topChoices' ? 'size' : 'similarpdtsize'}${size}`);
                if (sizeButton?.type) {
                    try {
                        if (availableSizes.has(size)) {
                            sizeButton.enable();
                            sizeButton.customClassList.remove("diagonal-cut");
                        } else {
                            sizeButton.disable();
                            sizeButton.customClassList.add("diagonal-cut");
                        }
                    } catch (err) {
                        console.error(`Error manipulating ${prefix} size ${size}:`, err);
                    }
                }
            });
        }

        const banner = $item(`#${prefix}Banner`);
        const bannerText = $item(`#${prefix}BannerText`);
        const redirectButton = $item(`#${prefix}RedirectButton`);
        if (itemData.link) {
            redirectButton.link = itemData.link;
            redirectButton.target = "_blank";
        }
        if (banner?.type && bannerText?.type) {
            if (!itemData.inStock) {
                banner.show();
                bannerText.text = "Out of Stock";
            } else {
                banner.hide();
                bannerText.text = "";
            }
        }

        const wishlistButton1 = $item(`#${prefix}Wishlist1`);
        const wishlistButton2 = $item(`#${prefix}Wishlist2`);

        if (wishlistButton1?.type && wishlistButton2?.type) {
            const isInWishlist = wishlistProductIds.has(itemData.productId);

            if (isInWishlist) {
                wishlistButton1.hide();
                wishlistButton2.show();
            } else {
                wishlistButton1.show();
                wishlistButton2.hide();
            }

            wishlistButton1.onClick(() => createWishlistHandler($item, itemData, true, prefix)());
            wishlistButton2.onClick(() => createWishlistHandler($item, itemData, false, prefix)());
        }
    } catch (err) {
        console.error(`Error in onItemReady for ${prefix} item ${index}:`, err);
    }
});
        const updateArrowVisibility = () => {
            if (FORMFACTOR !== "Desktop") {
                $w(`#${leftArrowId}`)?.hide();
                $w(`#${rightArrowId}`)?.hide();
                return;
            }

            $w(`#${leftArrowId}`)?.[startIndex > 0 ? "show" : "hide"]();
            $w(`#${rightArrowId}`)?.[startIndex < Math.max(0, data.length - ITEMS_PER_PAGE) ? "show" : "hide"]();

            if (data.length <= ITEMS_PER_PAGE) {
                $w(`#${leftArrowId}`)?.hide();
                $w(`#${rightArrowId}`)?.hide();
            }
        };

        const scrollRight = createOptimizedDebounce(() => {
            const maxStartIndex = Math.max(0, data.length - ITEMS_PER_PAGE);
            if (startIndex < maxStartIndex) {
                startIndex = Math.min(startIndex + ITEMS_PER_PAGE, maxStartIndex);
                $w(`#${repeaterId}`).data = data.slice(startIndex, startIndex + ITEMS_PER_PAGE);
                updateArrowVisibility();
                console.log(`Scrolled ${repeaterId} right to index ${startIndex}, showing items ${startIndex + 1} to ${Math.min(startIndex + ITEMS_PER_PAGE, data.length)}`);
            }
        }, DEBOUNCE_DELAY);

        const scrollLeft = createOptimizedDebounce(() => {
            startIndex = Math.max(0, startIndex - ITEMS_PER_PAGE);
            $w(`#${repeaterId}`).data = data.slice(startIndex, startIndex + ITEMS_PER_PAGE);
            updateArrowVisibility();
            console.log(`Scrolled ${repeaterId} left to index ${startIndex}, showing items ${startIndex + 1} to ${Math.min(startIndex + ITEMS_PER_PAGE, data.length)}`);
        }, DEBOUNCE_DELAY);

        if (FORMFACTOR === "Desktop") {
            $w(`#${repeaterId}`).data = data.slice(0, ITEMS_PER_PAGE);
            $w(`#${leftArrowId}`)?.onClick(scrollLeft);
            $w(`#${rightArrowId}`)?.onClick(scrollRight);
            updateArrowVisibility();
        } else {
            $w(`#${leftArrowId}`)?.hide();
            $w(`#${rightArrowId}`)?.hide();
            $w(`#${repeaterId}`).data = data;
        }

        $w(`#${sectionId}`).show();
    });
}